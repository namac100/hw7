#include <cmath>
#include <iostream>

using namespace std;

void dgl(double* f, double* R, double mu);
void rk3(double* R, double mu, double& dt);
void rk45(double* R, double mu, double& dt);

int main(){
  double dt = 0.01;
  double t = 0.0;
  double tend = 30.0;
  double mu = 0.012277471;
  double R[4];
  
  R[0] = 0.994;
  R[1] = 0.0;
  R[2] = 0.0;
  R[3] = -2.00158510637908;
  
  while(t < tend){
    rk3(R, mu, dt);
    cout << t << "\t" << dt << "\t" << R[0] << "\t" << R[1] << endl;
    t += dt;
  }
  
  return 0;
}

void dgl(double* f, double* R, double mu){
  
  double r,s, r0, r1, r2, r3;
  
  //Temporaere Variablen
  R[0] = r0;
  R[1] = r1;
  R[2] = r2;
  R[3] = r3;
  r = sqrt(pow((r0 + mu),2.0) + pow(r1,2.0));
  s = sqrt(pow((r0 - 1 + mu),2.0) + pow(r1,2.0));
  
  //Differentialgleichung
  R[0] = r2;
  R[1] = r3;
  R[2] = r0 + 2.0*r3 - ((1 - mu)*(r0 + mu))/pow(r,3.0) - mu*(r0 - 1.0 + mu)/pow(s,3.0);
  R[3] = r1 - 2.0*r2 - ((1 - mu)*r1)/pow(r,3.0) - mu*r1/pow(s,3.0);  
}

void rk3(double* R, double mu, double& dt){  
  double temp[4], K1[4], K2[4], K3[4];  
  
  dgl(K1, R, mu);
  temp[0] = R[0]+(dt/2.0)*K1[0];
  temp[1] = R[1]+(dt/2.0)*K1[1];
  temp[2] = R[2]+(dt/2.0)*K1[2];
  temp[3] = R[3]+(dt/2.0)*K1[3];
  
  dgl(K2, temp, mu);
  temp[0] = R[0] - dt*K1[0] + 2*dt*K2[0];
  temp[1] = R[1] - dt*K1[1] + 2*dt*K2[1];
  temp[2] = R[2] - dt*K1[2] + 2*dt*K2[2];
  temp[3] = R[3] - dt*K1[3] + 2*dt*K2[3];
  
  dgl(K3, temp, mu);
  R[0] += dt*((1/6.0)*K1[0] + (2/3.0)*K2[0] + (1/6.0)*K3[0]);
  R[1] += dt*((1/6.0)*K1[1] + (2/3.0)*K2[1] + (1/6.0)*K3[1]);
  R[2] += dt*((1/6.0)*K1[2] + (2/3.0)*K2[2] + (1/6.0)*K3[2]);
  R[3] += dt*((1/6.0)*K1[3] + (2/3.0)*K2[3] + (1/6.0)*K3[3]);
}

void rk45(double* R, double mu, double& dt){
  double K1[4], K2[4], K3[4], K4[4], K5[4], K6[4], K7[4];
  double temp[4], R4[4], R5[4], Rtemp[4];
  double max;
  double tol = 1E-5;
  
  dgl(K1, R, mu);
  temp[0] = R[0] + (dt/5.0) * K1[0];
  temp[1] = R[1] + (dt/5.0) * K1[1];
  temp[2] = R[2] + (dt/5.0) * K1[2];
  temp[3] = R[3] + (dt/5.0) * K1[3];
  
  dgl(K2, temp, mu);
  temp[0] = R[0] + dt * (3.0/40.0*K1[0] + 9.0/40.0*K2[0]);
  temp[1] = R[1] + dt * (3.0/40.0*K1[1] + 9.0/40.0*K2[1]);
  temp[2] = R[2] + dt * (3.0/40.0*K1[2] + 9.0/40.0*K2[2]);
  temp[3] = R[3] + dt * (3.0/40.0*K1[3] + 9.0/40.0*K2[3]);
  
  dgl(K3, temp, mu);
  temp[0] = R[0] + dt * (44.0/45.0*K1[0] - 56.0/15.0*K2[0] + 32.0/9.0*K3[0]);
  temp[1] = R[1] + dt * (44.0/45.0*K1[1] - 56.0/15.0*K2[1] + 32.0/9.0*K3[1]);
  temp[2] = R[2] + dt * (44.0/45.0*K1[2] - 56.0/15.0*K2[2] + 32.0/9.0*K3[2]);
  temp[3] = R[3] + dt * (44.0/45.0*K1[3] - 56.0/15.0*K2[3] + 32.0/9.0*K3[3]);
  
  dgl(K4, temp, mu);
  temp[0] = R[0] + dt * (19372.0/6561.0*K1[0] - 25360.0/2187.0*K2[0] + 64448.0/6561.0*K3[0] - 212.0/729.0*K4[0]);
  temp[1] = R[1] + dt * (19372.0/6561.0*K1[1] - 25360.0/2187.0*K2[1] + 64448.0/6561.0*K3[1] - 212.0/729.0*K4[1]);
  temp[2] = R[2] + dt * (19372.0/6561.0*K1[2] - 25360.0/2187.0*K2[2] + 64448.0/6561.0*K3[2] - 212.0/729.0*K4[2]);
  temp[3] = R[3] + dt * (19372.0/6561.0*K1[3] - 25360.0/2187.0*K2[3] + 64448.0/6561.0*K3[3] - 212.0/729.0*K4[3]);
  
  dgl(K5, temp, mu);
  temp[0] = R[0] + dt * (9017.0/3168.0*K1[0] - 355.0/33.0*K2[0] + 46732.0/5247.0*K3[0] + 49.0/176.0*K4[0] - 5103.0/18656.0*K5[0]);
  temp[1] = R[1] + dt * (9017.0/3168.0*K1[1] - 355.0/33.0*K2[1] + 46732.0/5247.0*K3[1] + 49.0/176.0*K4[1] - 5103.0/18656.0*K5[1]);
  temp[2] = R[2] + dt * (9017.0/3168.0*K1[2] - 355.0/33.0*K2[2] + 46732.0/5247.0*K3[2] + 49.0/176.0*K4[2] - 5103.0/18656.0*K5[2]);
  temp[3] = R[3] + dt * (9017.0/3168.0*K1[3] - 355.0/33.0*K2[3] + 46732.0/5247.0*K3[3] + 49.0/176.0*K4[3] - 5103.0/18656.0*K5[3]);
  
  dgl(K6, temp, mu);
  temp[0] = R[0] + dt * (35.0/384.0*K1[0] + 500.0/113.0*K3[0] + 125.0/192.0*K4[0] - 2187.0/6784.0*K5[0] + 11.0/84.0*K6[0]);
  temp[1] = R[1] + dt * (35.0/384.0*K1[1] + 500.0/113.0*K3[1] + 125.0/192.0*K4[1] - 2187.0/6784.0*K5[1] + 11.0/84.0*K6[1]);
  temp[2] = R[2] + dt * (35.0/384.0*K1[2] + 500.0/113.0*K3[2] + 125.0/192.0*K4[2] - 2187.0/6784.0*K5[2] + 11.0/84.0*K6[2]);
  temp[3] = R[3] + dt * (35.0/384.0*K1[3] + 500.0/113.0*K3[3] + 125.0/192.0*K4[3] - 2187.0/6784.0*K5[3] + 11.0/84.0*K6[3]);
  
  dgl(K7, temp, mu);
   
  //RK4
  R4[0] = R[0] + dt * (5179.0/57600.0*K1[0] + 7571.0/16695.0*K3[0] + 393.0/640.0*K4[0] - 92097.0/339200.0*K5[0] + 187.0/2100.0*K6[0] + 1.0/40.0*K7[0]);
  R4[1] = R[1] + dt * (5179.0/57600.0*K1[1] + 7571.0/16695.0*K3[1] + 393.0/640.0*K4[1] - 92097.0/339200.0*K5[1] + 187.0/2100.0*K6[1] + 1.0/40.0*K7[1]);
  R4[2] = R[2] + dt * (5179.0/57600.0*K1[2] + 7571.0/16695.0*K3[2] + 393.0/640.0*K4[2] - 92097.0/339200.0*K5[2] + 187.0/2100.0*K6[2] + 1.0/40.0*K7[2]);
  R4[3] = R[3] + dt * (5179.0/57600.0*K1[3] + 7571.0/16695.0*K3[3] + 393.0/640.0*K4[3] - 92097.0/339200.0*K5[3] + 187.0/2100.0*K6[3] + 1.0/40.0*K7[3]);
  
  //RK 5
  R5[0] = R[0] + dt * (35.0/384.0*K1[0] + 500.0/1113.0*K3[0] + 125.0/192.0*K4[0] - 2187.0/6784.0*K5[0] + 11.0/48.0*K6[0]);
  R5[1] = R[1] + dt * (35.0/384.0*K1[1] + 500.0/1113.0*K3[1] + 125.0/192.0*K4[1] - 2187.0/6784.0*K5[1] + 11.0/48.0*K6[1]);
  R5[2] = R[2] + dt * (35.0/384.0*K1[2] + 500.0/1113.0*K3[2] + 125.0/192.0*K4[2] - 2187.0/6784.0*K5[2] + 11.0/48.0*K6[2]);
  R5[3] = R[3] + dt * (35.0/384.0*K1[3] + 500.0/1113.0*K3[3] + 125.0/192.0*K4[3] - 2187.0/6784.0*K5[3] + 11.0/48.0*K6[3]);
  
  //Schrittweitentsteuerung
  Rtemp[0] = abs(R4[0]-R5[0]);
  Rtemp[1] = abs(R4[1]-R5[1]);
  Rtemp[2] = abs(R4[2]-R5[2]);
  Rtemp[3] = abs(R4[3]-R5[3]);
 
  //Berechne Maximum
  max = Rtemp[0];
  
  for(int i=1; i<4; i++){  
    if(Rtemp[i] > max){
       max = Rtemp[i];
       cout << max;
    }
  }
  
  //Schreibe Ergebnis des RK4 in R
  R = R4;
  
  //Setze neue Schrittweite
  dt *= pow((tol/max),0.2)*0.8;
  
}
